# Default values for NeuronDB
# This is a YAML-formatted file.

global:
  imageRegistry: ""
  imagePullSecrets: []

# NeuronDB PostgreSQL
neurondb:
  enabled: true
  image:
    repository: ghcr.io/neurondb/neurondb-postgres
    tag: "2.0.0-pg17-cpu"
    pullPolicy: IfNotPresent

  postgresql:
    version: "17"
    database: "neurondb"
    username: "neurondb"
    password: "" # Set via secret
    port: 5432
    config: "" # Optional postgresql.conf content
    # External PostgreSQL configuration
    external:
      enabled: false  # Set to true to use external PostgreSQL
      host: ""  # External PostgreSQL host (required if external.enabled=true)
      port: 5432  # External PostgreSQL port
      database: "neurondb"  # Database name
      username: "neurondb"  # Username
      # Connection string format: postgresql://user:pass@host:port/db
      # If connectionString is provided, it takes precedence over individual fields
      connectionString: ""  # Full connection string (alternative to individual fields)
      # Secret containing connection details (alternative to connectionString)
      # Secret should contain keys: host, port, database, username, password
      # Or a single key: connection-string
      secretName: ""  # Name of secret containing connection details
      secretKeys:
        host: "host"
        port: "port"
        database: "database"
        username: "username"
        password: "password"
        connectionString: "connection-string"  # Alternative: single key with full connection string

  persistence:
    enabled: true
    size: 50Gi
    storageClass: ""
    # PVC retention policy: "Retain", "Delete", or "Recycle" (deprecated)
    # When set to "Retain", PVCs are kept when StatefulSet is deleted
    retentionPolicy: "Retain"
    # Enable volume expansion (requires storage class to support it)
    allowVolumeExpansion: false

  # StatefulSet configuration
  replicas: 1
  # podManagementPolicy: "OrderedReady" (default) or "Parallel"
  # OrderedReady: Pods are created/updated/deleted in order (0, 1, 2...)
  # Parallel: Pods are created/updated/deleted in parallel
  podManagementPolicy: "OrderedReady"
  updateStrategy:
    type: "RollingUpdate"  # "RollingUpdate" or "OnDelete"
    rollingUpdate:
      # Partition for canary deployments (pods with ordinal >= partition are updated)
      # Set to replicas count to prevent updates, then reduce for gradual rollout
      partition: null
      # Maximum number of pods that can be unavailable during update
      # Only valid for RollingUpdate with maxUnavailable (requires Kubernetes 1.24+)
      maxUnavailable: null

  podDisruptionBudget:
    enabled: true
    minAvailable: 1

  resources:
    requests:
      memory: "4Gi"
      cpu: "2"
    limits:
      memory: "8Gi"
      cpu: "4"

  service:
    type: ClusterIP
    port: 5432

  securityContext:
    readOnlyRootFilesystem: false  # Set to true for maximum security (requires tmpfs volumes)

  healthCheck:
    checkTables: true  # Check if critical tables exist in readiness probe
    requireTables: false  # Require tables to exist (set to true for strict checking)
    readinessProbe:
      initialDelaySeconds: 10
      periodSeconds: 5
      timeoutSeconds: 3
      failureThreshold: 3
      successThreshold: 1
    livenessProbe:
      initialDelaySeconds: 30
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 5

  # Resource governance
  nodeSelector: {}
  affinity: {}
  tolerations: []
  topologySpreadConstraints: []
  priorityClassName: ""  # Use PriorityClass from resourceGovernance if enabled

# NeuronAgent
neuronagent:
  enabled: true
  image:
    repository: ghcr.io/neurondb/neuronagent
    tag: "2.0.0"
    pullPolicy: IfNotPresent

  replicas: 2
  logLevel: "info"
  initWaitForDB: true

  resources:
    requests:
      memory: "512Mi"
      cpu: "500m"
    limits:
      memory: "2Gi"
      cpu: "2"

  service:
    type: ClusterIP
    port: 8080

  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70
    # Advanced HPA with custom metrics
    advanced:
      enabled: false
      minReplicas: 2
      maxReplicas: 10
      metrics:
        cpu:
          enabled: true
          targetUtilization: 70
        memory:
          enabled: false
          targetUtilization: 80
        httpRPS:
          enabled: false
          metricName: "http_requests_per_second"
          targetValue: "100"
        queueDepth:
          enabled: false
          metricName: "queue_depth"
          targetValue: "100"
        latencyP95:
          enabled: false
          metricName: "http_request_duration_seconds_p95"
          targetValue: "0.5"
      behavior:
        scaleDown:
          stabilizationWindowSeconds: 300
          policies:
            percent: 50
            periodSeconds: 60
        scaleUp:
          stabilizationWindowSeconds: 0
          policies:
            percent: 100
            pods: 2
            periodSeconds: 60
    # KEDA autoscaling
    keda:
      enabled: false
      minReplicas: 2
      maxReplicas: 10
      pollingInterval: 30
      cooldownPeriod: 300
      idleReplicaCount: 0
      triggers:
        http:
          enabled: false
          prometheusServer: "http://prometheus:9090"
          metricName: "http_requests_per_second"
          threshold: "100"
          query: "sum(rate(http_requests_total[2m]))"
        queueDepth:
          enabled: false
          query: "SELECT COUNT(*) FROM neurondb_agent.job_queue WHERE status = 'pending';"
          targetValue: "100"
        customPrometheus:
          enabled: false
          prometheusServer: "http://prometheus:9090"
          metricName: ""
          threshold: ""
          query: ""

  podDisruptionBudget:
    enabled: true
    minAvailable: 1
    maxUnavailable: 1

  securityContext:
    readOnlyRootFilesystem: false  # Set to true for maximum security (requires tmpfs volumes)

  healthCheck:
    readinessProbe:
      path: "/health"
      initialDelaySeconds: 10
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 3
      successThreshold: 1
    livenessProbe:
      path: "/health"
      initialDelaySeconds: 30
      periodSeconds: 30
      timeoutSeconds: 10
      failureThreshold: 3

  # Resource governance
  nodeSelector: {}
  affinity: {}
  tolerations: []
  topologySpreadConstraints: []
  priorityClassName: ""  # Use PriorityClass from resourceGovernance if enabled

# NeuronMCP
neuronmcp:
  enabled: true
  image:
    repository: ghcr.io/neurondb/neuronmcp
    tag: "2.0.0"
    pullPolicy: IfNotPresent

  replicas: 1
  logLevel: "info"
  initWaitForDB: true

  resources:
    requests:
      memory: "256Mi"
      cpu: "250m"
    limits:
      memory: "1Gi"
      cpu: "1"

  securityContext:
    readOnlyRootFilesystem: false  # Set to true for maximum security (requires tmpfs volumes)

  # Resource governance
  nodeSelector: {}
  affinity: {}
  tolerations: []
  topologySpreadConstraints: []
  priorityClassName: ""  # Use PriorityClass from resourceGovernance if enabled

# NeuronDesktop
neurondesktop:
  enabled: true
  api:
    image:
      repository: ghcr.io/neurondb/neurondesktop-api
      tag: "2.0.0"
      pullPolicy: IfNotPresent

    replicas: 2
    database: "neurondesk"
    logLevel: "info"
    initWaitForDB: true

    resources:
      requests:
        memory: "256Mi"
        cpu: "250m"
      limits:
        memory: "1Gi"
        cpu: "1"

    service:
      type: ClusterIP
      port: 8081

    securityContext:
      readOnlyRootFilesystem: false  # Set to true for maximum security (requires tmpfs volumes)

    healthCheck:
      readinessProbe:
        path: "/health"
        initialDelaySeconds: 10
        periodSeconds: 10
        timeoutSeconds: 5
        failureThreshold: 3
        successThreshold: 1
      livenessProbe:
        path: "/health"
        initialDelaySeconds: 30
        periodSeconds: 30
        timeoutSeconds: 10
        failureThreshold: 3

    # Resource governance
    nodeSelector: {}
    affinity: {}
    tolerations: []
    topologySpreadConstraints: []
    priorityClassName: ""

  frontend:
    image:
      repository: ghcr.io/neurondb/neurondesktop-frontend
      tag: "2.0.0"
      pullPolicy: IfNotPresent

    replicas: 2

    resources:
      requests:
        memory: "128Mi"
        cpu: "100m"
      limits:
        memory: "512Mi"
        cpu: "500m"

    service:
      type: ClusterIP
      port: 3000

    securityContext:
      readOnlyRootFilesystem: false  # Set to true for maximum security (requires tmpfs volumes)

    # Resource governance
    nodeSelector: {}
    affinity: {}
    tolerations: []
    topologySpreadConstraints: []
    priorityClassName: ""

# Ingress
ingress:
  enabled: false
  className: "nginx"
  annotations: {}
  hosts:
    - host: neurondb.example.com
      paths:
        - path: /
          pathType: Prefix
  apiEnabled: false  # Enable API and agent endpoints via ingress
  tls: []

# Secrets
secrets:
  create: true
  postgresPassword: "" # Auto-generated if empty (32 char random)
  agentApiKeys: [] # List of API keys

# External Secrets Integration
externalSecrets:
  enabled: false
  # External Secrets Operator
  operator:
    enabled: false
    refreshInterval: "1h"
    secretStoreRef:
      name: "default"
      kind: "SecretStore"  # "SecretStore" or "ClusterSecretStore"
    target:
      creationPolicy: "Owner"  # "Owner" or "Merge" or "None"
    secrets:
      postgresPassword:
        key: "postgres-password"
        remoteRef:
          key: "neurondb/postgres-password"  # Path in external secret store
          property: ""  # Optional property within the secret
      agentApiKeys:
        key: "agent-api-keys"
        remoteRef:
          key: "neurondb/agent-api-keys"
          property: ""
    externalPostgresSecrets: []  # Array of {key, remoteRef: {key, property}} for external PostgreSQL
  # CSI Secrets Store Driver
  csi:
    enabled: false
    provider: "aws"  # "aws", "azure", or "gcp"
    aws:
      region: "us-east-1"
      secretName: "neurondb/postgres-password"
    azure:
      keyVaultName: ""
      tenantId: ""
      secretName: "postgres-password"
    gcp:
      secretName: "projects/PROJECT_ID/secrets/postgres-password"

# ServiceAccount (legacy, for backward compatibility)
serviceAccount:
  create: true
  name: ""
  annotations: {}

# RBAC
rbac:
  enabled: true
  createRoles: true
  serviceAccounts:
    neurondb:
      create: true
      annotations: {}
      automountServiceAccountToken: true
    neuronagent:
      create: true
      annotations: {}
      automountServiceAccountToken: true
    neuronmcp:
      create: true
      annotations: {}
      automountServiceAccountToken: true
    neurondesktopApi:
      create: true
      annotations: {}
      automountServiceAccountToken: true
    neurondesktopFrontend:
      create: true
      annotations: {}
      automountServiceAccountToken: true

# NetworkPolicy
networkPolicy:
  enabled: false  # Enable for production security
  allowMonitoring: true  # Allow monitoring tools to scrape metrics
  monitoringNamespace: ""  # Namespace for monitoring (defaults to release namespace)
  monitoringLabels: {}  # Labels for monitoring pods (defaults to app: prometheus)
  ingressNamespace: ""  # Namespace for ingress controller (defaults to release namespace)
  ingressLabels: {}  # Labels for ingress controller pods (defaults to app.kubernetes.io/name: ingress-nginx)
  allowedNamespaces: []  # Namespaces allowed to access NeuronMCP (empty = same namespace only)

# Observability
observability:
  # Prometheus Operator integration
  prometheusOperator:
    enabled: false  # Set to true if using Prometheus Operator
    serviceMonitor:
      enabled: true
      interval: "30s"
      metricsPath: "/metrics"
      additionalLabels: {}
      neuronmcp:
        enabled: false  # NeuronMCP doesn't expose HTTP metrics (MCP protocol only)
    prometheusRule:
      enabled: true
      additionalLabels: {}
  # OpenTelemetry configuration
  openTelemetry:
    enabled: false
    endpoint: ""  # OTLP endpoint
    exporter:
      otlp:
        endpoint: ""
        insecure: false
        headers: {}
    resource:
      serviceName: "neurondb"
      serviceVersion: "2.0.0"

# Monitoring
monitoring:
  enabled: true
  prometheus:
    enabled: true
    image:
      repository: prom/prometheus
      tag: "latest"
      pullPolicy: IfNotPresent
    scrapeInterval: "15s"
    evaluationInterval: "15s"
    clusterName: "neurondb"
    environment: "production"
    retention: "30d"
    persistence:
      enabled: true
      size: "20Gi"
      storageClass: ""
    resources:
      requests:
        memory: "512Mi"
        cpu: "250m"
      limits:
        memory: "2Gi"
        cpu: "1"
    postgresExporter:
      enabled: false
      port: 9187
    alertmanager:
      enabled: false
      image:
        repository: prom/alertmanager
        tag: "latest"
        pullPolicy: IfNotPresent
      persistence:
        enabled: true
        size: "2Gi"
        storageClass: ""
      resources:
        requests:
          memory: "128Mi"
          cpu: "100m"
        limits:
          memory: "512Mi"
          cpu: "500m"
      service:
        type: ClusterIP
        port: 9093
      webhook:
        url: ""  # Set to your webhook endpoint URL
        criticalUrl: ""  # Optional: separate URL for critical alerts
  grafana:
    enabled: true
    image:
      repository: grafana/grafana
      tag: "latest"
      pullPolicy: IfNotPresent
    adminUser: "admin"
    adminPassword: "admin"  # Change in production!
    rootUrl: "/"
    persistence:
      enabled: true
      size: "10Gi"
      storageClass: ""
    resources:
      requests:
        memory: "128Mi"
        cpu: "100m"
      limits:
        memory: "512Mi"
        cpu: "500m"
  jaeger:
    enabled: true
    image:
      repository: jaegertracing/all-in-one
      tag: "latest"
      pullPolicy: IfNotPresent
    resources:
      requests:
        memory: "256Mi"
        cpu: "100m"
      limits:
        memory: "1Gi"
        cpu: "500m"

# Migrations
migrations:
  enabled: true
  image:
    repository: postgres
    tag: "17"
    pullPolicy: IfNotPresent
  waitImage:
    repository: postgres
    tag: "17"
  # Custom migration script (optional)
  # If provided, this script will be executed instead of default migration logic
  script: ""
  backoffLimit: 3
  activeDeadlineSeconds: 600
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "512Mi"
      cpu: "500m"

# Resource Governance
resourceGovernance:
  priorityClass:
    enabled: true
    value: 1000  # Priority value (higher = more important)
    preemptionPolicy: "PreemptLowerPriority"  # "PreemptLowerPriority" or "Never"

# Backup
backup:
  enabled: true
  schedule: "0 2 * * *" # Daily at 2 AM (cron format)
  retention: 30 # days
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1
  activeDeadlineSeconds: 3600
  image:
    repository: postgres
    tag: "17"
    pullPolicy: IfNotPresent
  waitImage:
    repository: postgres
    tag: "17"
  persistence:
    enabled: false
    size: "20Gi"
    storageClass: ""
  resources:
    requests:
      memory: "512Mi"
      cpu: "500m"
    limits:
      memory: "2Gi"
      cpu: "2"
  # S3 backup configuration
  s3:
    enabled: false
    bucket: ""
    region: ""
    prefix: "backups"  # Prefix for backup files in S3
    accessKeyId: ""  # Set via secret or use IAM role
    secretAccessKey: ""  # Set via secret or use IAM role
  # GCS backup configuration
  gcs:
    enabled: false
    bucket: ""
    prefix: "backups"  # Prefix for backup files in GCS
    credentialsJson: ""  # Base64 encoded service account JSON
  # Azure Blob Storage backup configuration
  azure:
    enabled: false
    accountName: ""
    containerName: ""
    prefix: "backups"  # Prefix for backup files in Azure
    clientId: ""  # Set via secret
    clientSecret: ""  # Set via secret
    tenantId: ""  # Set via secret
  # Restore configuration
  restore:
    enabled: false  # Set to true and provide backupFile to trigger restore
    backupFile: ""  # Name of backup file to restore (e.g., "neurondb-backup-20240101-020000.dump")
    fromS3: false  # Set to true if backup is in S3
    fromGCS: false  # Set to true if backup is in GCS
    fromAzure: false  # Set to true if backup is in Azure Blob Storage
    activeDeadlineSeconds: 3600
    persistence:
      enabled: false
    resources:
      requests:
        memory: "1Gi"
        cpu: "1"
      limits:
        memory: "4Gi"
        cpu: "4"
